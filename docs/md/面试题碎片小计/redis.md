# **持久化**

**rdb**：每次都是生成一个全量快照。fork一个子进程，将数据写入临时文件，持久化完成会替换旧的RDB

​	save: 会阻塞当前线程

​	bgsave: fork出子进程

​	redis.conf文件中：

​		save 3600 1   3600秒有一个key被修改，出发RDB

​		save 300 100

默认开始RDB，最近一次的修改可能会丢失。

**aof**

​	需要再配置文件中手动开启。appendOnly yes

​	写命令都会追加到AOF缓冲区，缓冲区根据配置的**同步策略**来同步到磁盘上的AOF文件中，AOF大小达到阈值，进行重写瘦身

​	同步策略：

​	appendfsync always  每次操作都刷盘，不可取

​	appendfsync everysec	每隔一秒刷一次盘，可能会丢失一秒的数据

​	appendfsync no

aof文件较大，恢复较慢

​	

**混合持久化**

aof-user-rdb-preamble yes开启，redis4.0默认开启

appendonlydir下会存在一个rdb文件和一个aof文件



# 过期策略

惰性删除：访问时如果过期才删除，优化CPU资源，堆内存不友好

定期删除：默认100毫秒随机检查一部分设置了过期时间的key

# 内存淘汰策略

不淘汰：

volatile: lru最近最少使用，ttl，random

allkeys:lru,random

还有个LFU，高版本才有，记录key的访问频率，可以探测热点数据，redis4.0新增

# 缓存击穿，雪崩，穿透

击穿：访问一个key，刚好过期，大量打在数据库上；永不过期，较长时间，互斥锁

雪崩：大规模key同时失效。设置随机时间，多级缓存，互斥锁，redis高可用主从架构

穿透：请求一个缓存和数据库都不存在的key。缓存空对象，参数校验，布隆过滤器



# redis哨兵机制



# 缓存一致性问题

延迟双删

队列+重试机制

异步更新缓存，基于binlog的方式

# 分布式锁

lua脚本

redisson

REDLOCK：红锁。

# redis事务

redis事务：multi开启一个事务，然后将命令放入一个队列中，执行exec时才开始顺序执行命令

这一堆命令要么全部执行，要么全部不执行
全部执行：即使中间某个命令报错，也会继续执行下一个命令
全部不执行：使用watch命令实现乐观锁，监控多个key，如果在exec执行前这些key的值改变了，事务就不执行

discard也可以清空事务队列退出事务状态不执行事务

出现语法错误时：停止后续命令
出现执行错误时：继续执行后续命令



# 哈希冲突

链式哈希。链表边长rehash，但是不是一次把hash表中的数据映射到另一张表，通过一种**渐进式**的方式，将rehash分散到多次请求过程中，避免阻塞

渐进式哈希：

分配新哈希表，大小为2倍，保留旧表

每次增删查操作时，将旧表的一个桶迁移到新表，reindex记录进度

迁移完成释放旧表

# 幂等性保证

数据库唯一字段

乐观锁：版本号

分布式锁



redis最多存储2的32次方-1，约42亿个key，redis内部使用哈希表，采用32为有符号整数作为索引。哈希函数和负载因子也会影响