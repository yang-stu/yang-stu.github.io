### 1、使用 Redisson 分布式锁时，未能获取锁的线程会阻塞，它们是如何被唤醒的

分布式锁基于lua脚本和发布订阅(pub/sub)机制

未获取锁的线程：

向 Redis 注册监听器（订阅 unlock 消息）

挂起等待（阻塞在 `tryLock()` 内部）

当前持锁者释放锁时，Redisson 会发送一个“锁释放”的消息

等待中的线程接收到消息后被唤醒，重新尝试加锁



在第一次尝试获取锁失败时，会根据锁的名称生成一个特定的Redis Pub/Sub 频道名，并**订阅该频道**用于接收“锁释放”的通知

Redisson 内部会用一个线程（通常是 Netty EventLoop）注册监听这个频道

这个过程发生在 `tryLock()` 或 `lock()` 第一次尝试失败之后



Pub/Sub消息无持久化，不保证消息可达。

如果因为网络波动等没有收到unlock消息，redission有兜底机制。

内部有一个**定时调度器（ScheduledExecutor）**，会周期性尝试再次获取锁（通常每 100ms～1s 可配置）。

同时，`tryLock(timeout)` 中设置的 timeout 会限制最大等待时间，防止死等



看门狗机制：一般tryLock里面有3个参数就不会触发，tryLock(waitTime, leaseTime, TimeUnit)，三个参数第二个leaseTime有值就不会触发看门狗机制，这个代表锁的持有时间，waitTime代表最大等待时间



### 2、使用定时任务轮询来尝试唤醒这些阻塞的线程，这种方式可行吗？为什么

可行。有效避免线程长时间挂起

但是浪费CPU资源，频繁请求，高并发场景不考虑；为控制轮训次数，可能导致死循环



### 3、动态多数据源切换是如何实现的？其基本原理是什么

核心：

AbstractRoutingDataSource：		Spring 提供的抽象类，根据上下文动态返回当前数据源

ThreadLocal：存储当前线程选择的数据源标识



### 4、ThreadLocal 可能导致内存泄漏吗？为什么？如何避免

**`ThreadLocal` 的值** 是绑定到当前线程的，因此在 `ThreadLocal` 中存储的对象会被保留在该线程的上下文中，直到线程被销毁

如果 `ThreadLocal` 中的值没有及时清除，当该线程被复用时，之前的 `ThreadLocal` 值会被“遗留”在该线程中，从而导致 **内存泄漏**

等于就是线程池的问题，因为线程复用，线程不销毁，存储的对象不显式回收就会一直存在

复用的线程重新set会覆盖原来的值，但是覆盖了以后，当前线程指向新的对象，原来的对象断开引用，是强引用对象，不会被GC回收

为什么旧的对象断开连接了，不会被当做垃圾回收



阿里巴巴：TransmittableThreadLocal管理threadlocal